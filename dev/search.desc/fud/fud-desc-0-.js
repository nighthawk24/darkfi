searchState.loadedDescShard("fud", 0, "Bitcoin\nChunk transfer timeout in seconds\n<code>DhtHandler</code> implementation and fud-specific DHT structs\nThe DHT instance\nDownload methods\nDefault download directory\nEqui-X Proof-of-Work using Equi-X\nFudEvent\nUsed to send events to fud clients\nGlobal multithreaded executor reference\nDownload a file or directory from the network to <code>path</code>. …\nCurrently active downloading tasks (running the …\nSled tree containing “resource hash -&gt; file selection”…\nReturns the argument unchanged.\nThe Geode instance\nStart downloading a file or directory from the network to …\nTry to get the chunked file or directory from geode, if we …\nGet requests receiver\nGet requests sender\nGet resource path from hash using the sled db\nBootstrap the DHT, verify our resources, add ourselves to …\nInsert a file or directory from the file system. Called …\nCalls <code>U::from(self)</code>.\nLookup requests receiver\nCurrently active lookup tasks (running the …\nLookup requests sender\nCreate a new <code>dht::FudSeeder</code> for own node\nOur own <code>VerifiableNodeData</code>\nPointer to the P2P network instance\nGet resource hash from path using the sled db\nSled tree containing “resource hash -&gt; path on the …\nPoW\nThe <code>FudPow</code> instance\nP2P protocols\nRemove seeders that are older than <code>expiry_secs</code>\nAdd a resource from the file system.\nPut requests receiver\nCurrently active put tasks (running the …\nPut requests sender\nRemoves:\nResource definition\nResources (current status of all downloads/seeds)\nJSON-RPC related methods\nScrap definition\nSled tree containing scraps which are chunks containing …\nOur secret key (the public key is in <code>node_data</code>)\nSettings and args\nStop all tasks.\nBackground tasks\nCurrently active tasks (defined in <code>tasks</code>, started with the …\nUtils\nIterate over chunks and find which chunks are available …\nVerify if resources are complete and uncorrupted. If a …\nA struct that can fetch and store recent Bitcoin block …\nCurrent list of block hashes, the most recent block is at …\nConvert concatenated BTC block headers to a list of block …\nGlobal multithreaded executor reference\nFetch the current BTC height using an Electrum node RPC.\nFetch <code>self.count</code> BTC block hashes from <code>height</code> using an …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nPoW settings which includes BTC/Electrum settings\nFetch block hashes from Electrum nodes, and update …\nThe values of the DHT are <code>Vec&lt;FudSeeder&gt;</code>, mapping resource …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nResource that this seeder provides\nSeeder’s node data\nWhen this <code>FudSeeder</code> was added to our hash table. This is …\nFetch a single chunk and return what should be done next\nFetch <code>chunks</code> for <code>chunked</code> (file or directory) from seeders …\nFetch a single resource metadata from seeders received …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProcesses an incoming chunk\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReceive seeders from a subscription, and execute an async …\nA challenge string\nChoose the compiled runtime only, and fail if it …\n<code>crate::RuntimeOption::CompileOnly</code> is in use and the …\nBuilder for creating <code>EquiX</code> instances with custom settings\nErrors that could occur while building a hash function\nChoose the interpreted runtime, without trying the …\nLength of the nonce value generated by clients and …\nNumber of bytes in the packed representation of a solution\nNumber of items (selected hash inputs) in each solution\nAlgorithm personalization string\nLength of the personalization string, in bytes\nA whole-program constraint in HashX failed, and this …\nOption for selecting a HashX runtime\nSize of the solver memory region, in bytes\nPotential solution to an EquiX puzzle\nTemporary memory used by the Equi-X solver\nAlways try the compiler first but fall back to the …\nBuild an <code>EquiX</code> instance with a challenge string and the …\nThe next <code>Challenge</code> to try\nVerify that a solution proof passes the effort test.\nTarget effort\nConfiguration settings for Equi-X\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a hex formatted string of the data (big endian)\nIncrement the nonce value inside this challenge.\nClone the input portion of this challenge.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTemporary memory for Equi-X to use\nNew uninitialized memory, usable as solver temporary space.\nCreate a new <code>EquiXBuilder</code> with default settings.\nBuild a new <code>Challenge</code>.\nClone the nonce portion of this challenge.\nSelect a new <code>RuntimeOption</code>.\nSearch for solutions to a particular challenge.\nReturn the packed byte representation of this Solution.\nBuild a <code>Solution</code> from an array of items, checking that the …\nBuild a <code>Solution</code> from a fixed size byte array, checking …\nCheck a <code>Solution</code> against a particular challenge string.\nCheck a <code>SolutionItemArray</code>.\nCheck a <code>SolutionByteArray</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMacro calling <code>fud.event_publisher.notify()</code>\nStruct handling a <code>EquiXPow</code> instance to generate and verify …\nThe data needed to verify a fud PoW.\nElectrum nodes used to fetch the latest block hashes (used …\nElectrum nodes used to fetch the latest block hashes (used …\nNumber of latest BTC block hashes that are valid for fud’…\nNumber of latest BTC block hashes that are valid for fud’…\nElectrum nodes timeout in seconds\nElectrum nodes timeout in seconds\nThe Equi-X challenge.\nEqui-X effort value\nEqui-X effort value\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a random keypair and run the PoW to get a …\nThe node id on the DHT.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the Equi-X solution in a <code>VerifiableNodeData</code> is …\nMessage representing a node announcing a key on the network\nMessage representing a chunk reply from the network\nMessage representing a directory reply from the network\nMessage representing a file reply from the network\nMessage representing a find nodes reply on the network\nMessage representing a find nodes request on the network\nMessage representing a find file/chunk request from the …\nMessage representing a find seeders reply on the network\nMessage representing a find seeders request on the network\nMessage representing a chunk reply when a file is not found\nMessage representing a ping reply on the network\nMessage representing a ping request on the network\nP2P protocol implementation for fud.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nIf the FudFindRequest matches a chunk we have, handle it. …\nIf the FudFindRequest matches a file we have, handle it …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSignature of the random u64 from the ping request\nStructure representing the current state of a file or …\nThe files the user wants to download\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nComputes and returns download ETA in seconds using the …\nReturns the number of bytes we want from a chunk (depends …\nReturns the (sub)set of chunk hashes in a ChunkedStorage …\nReturns the list of selected files (absolute paths).\nResource hash (used as key in the DHT)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPath of the resource on the filesystem\nResource type (file or directory)\nRecent speeds in bytes/sec, used to compute the download …\nCurrent status of the resource\nData (in bytes) we already downloaded, but only data we …\nData (in bytes) we want to download\nNumber of chunks we want to download\nNumber of chunks we already downloaded, but only those we …\nData (in bytes) we already downloaded\nTotal size (in bytes) of the resource\nTotal number of chunks\nNumber of chunks we already downloaded\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nHash of the data that was last written to the file system …\nCalls <code>U::from(self)</code>.\nBase directory for filesystem storage\nChunk transfer timeout in seconds\nConfiguration file to use\nDHT settings\nDefault path to store downloaded files (defaults to &lt;…\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nSet log file path to output daemon logs into\nNetwork settings\nPoW settings\nJSON-RPC settings\nIncrease verbosity (-vvv supported)\nBackground task that announces our files once every hour. …\nTriggered when calling the <code>fud.get()</code> method. It creates a …\nTriggered when you need to lookup seeders for a resource.\nBackground task that:\nTriggered when calling the <code>fud.put()</code> method.\nAn enum to represent a set of files, where you can use <code>All</code> …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.")