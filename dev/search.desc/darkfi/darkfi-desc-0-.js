searchState.loadedDescShard("darkfi", 0, "This macro is used for a standard way of daemonizing …\nChunk-based file storage implementation. This is a …\nImplements default Hash, PartialEq, and Eq for a struct …\n<code>src/zkas</code> is the library holding the zkas toolchain, …\nStructure holding all sled trees that define the concept …\nOverlay structure over a <code>Blockchain</code> instance.\nAtomic pointer to blockchain overlay.\nAtomic pointer to sled db overlay.\nInsert a given <code>BlockInfo</code> into the overlay. This functions …\nInsert a given <code>BlockInfo</code> into the blockchain database. …\nInsert a given slice of pending transactions into the …\nAuxiliary function to write to multiple trees completely …\nBlock related definitions and storage implementations\nBlocks overlay\nBlocks sled tree\nCheckpoint overlay so we can revert to it, if needed.\nContracts and Wasm storage implementations\nContract overlay\nContracts related sled trees\nReturns the argument unchanged.\nReturns the argument unchanged.\nAuxiliary function to create a full clone using …\nRetrieve genesis (first) block height and hash.\nRetrieve genesis (first) block info.\nRetrieve all blocks contained in the blockchain in order. …\nRetrieve <code>BlockInfo</code>s by given hashes. Fails if any of them …\nRetrieve <code>BlockInfo</code>s by given hashes. Fails if any of them …\nRetrieve <code>BlockInfo</code>s by given heights. Does not fail if any …\nRetrieve all <code>BlockInfo</code> for given slice of <code>Block</code>. Fails if …\nRetrieve all <code>BlockInfo</code> for given slice of <code>Block</code>. Fails if …\nRetrieve <code>Block</code>s by given hashes and return their …\nRetrieve <code>BlockInfo</code>s by given heights range.\nRetrieve n headers before given block height.\nRetrieve <code>Header</code>s by given hashes. Fails if any of them is …\nRetrieve last ‘N’ <code>BlockInfo</code>s from the blockchain.\nRetrieve all transactions from the pending tx store. Be …\nGenerate a Monotree(SMT) containing all contracts states …\nGenerate a Monotree(SMT) containing all contracts states …\nCheck if the given <code>BlockInfo</code> is in the database and all …\nCheck if the given <code>BlockInfo</code> is in the database and all …\nCheck if block order for the given height is in the …\nHeader definition and storage implementation\nHeaders overlay\nHeaders sled tree\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if blockchain contains any blocks\nCheck if blockchain contains any blocks\nRetrieve the last block height and hash.\nRetrieve the last block height and hash.\nRetrieve the last block info.\nRetrieve the last block info.\nRetrieve the last block difficulty. If the tree is empty, …\nRetrieve the last block height.\nRetrieve the last block timestamp.\nRetrieve the last block header.\nRetrieve stored blocks count\nMonero definitions needed for merge mining\nInstantiate a new <code>BlockchainOverlay</code> over the given …\nInstantiate a new <code>Blockchain</code> with the given <code>sled</code> database.\nMain <code>sled_overlay::SledDbOverlay</code> to the sled db connection\nRemove a given slice of pending transactions from the …\nRemove a given slice of pending transactions hashes from …\nAuxiliary function to reset the blockchain and consensus …\nRevert to current overlay checkpoint.\nMain pointer to the sled db connection\nTransactions overlay\nTransactions related sled trees\nTransactions related storage implementations\nRetrieve stored txs count\nThis struct represents a tuple of the form (<code>header</code>, <code>txs</code>, …\nAuxiliary structure used to keep track of block PoW …\nStructure representing full block data.\nAuxiliary structure used to keep track of blocks order.\nAuxiliary structure used to keep track of block ranking …\nThe <code>BlockStore</code> is a structure representing all <code>sled</code> trees …\nOverlay structure over a <code>BlockStore</code> instance.\nAppend a transaction to the block. Also adds it to the …\nAuxiliary function to append a transaction to a Merkle …\nAppend a vector of transactions to the block. Also adds …\nBlock header hash of that height\nCheck if the store’s main tree contains a given block …\nCheck if the store’s order tree contains a given height.\nHeight cumulative difficulty (total + height difficulty)\nRepresents the genesis block on current timestamp\nHeight difficulty\nThe <code>sled</code> tree storing the difficulty information of the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenerate a <code>Block</code> from a <code>BlockInfo</code>\nRepresents the genesis block difficulty\nFetch given block hashes from the overlay’s main tree. …\nFetch given block hashes from the store’s main tree. The …\nRetrieve all blocks from the store’s main tree in the …\nFetch all hashes after given height. In the iteration, if …\nRetrieve all block difficulties from the store’s …\nRetrieve complete order from the store’s order tree in …\nFetch n hashes before given height. In the iteration, if …\nFetch N records before given height from the store’s …\nFetch given block height numbers from the store’s …\nFetch the first block hash in the order tree, based on the …\nFetch the last block hash in the overlay’s order tree, …\nFetch the last block hash in the order tree, based on the …\nFetch the last record in the difficulty tree, based on the …\nFetch the last N records from the store’s difficulty …\nFetch the last N records from order tree\nFetch given heights from the overlay’s order tree. The …\nFetch given heights from the store’s order tree. The …\nFetches the blocks within a specified range of height from …\nFetch given block height numbers from the store’s state …\nFetch all state inverse diffs after given height. In the …\nA block’s hash is the same as the hash of its header\nA block’s hash is the same as the hash of its header\nBlock hash rank\nHeight cumulative hashes rank\nBlock header\nBlock header data\nBlock height\nBlock height number\nInsert a slice of <code>Block</code> into the overlay’s main tree. …\nInsert a slice of <code>Block</code> into the store’s main tree.\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nInsert a slice of <code>BlockDifficulty</code> into the overlay’s …\nInsert a slice of <code>BlockDifficulty</code> into the store’s …\nInsert a slice of <code>u32</code> and block hashes into overlay’s …\nInsert a slice of <code>u32</code> and block hashes into the store’s …\nInsert a slice of <code>u32</code> and block inverse diffs into the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if overlay’s order tree contains any records.\nCheck if store’s order tree contains any records.\nRetrieve store’s order tree records count.\nMain <code>sled</code> tree, storing all the blockchain’s blocks, …\nOpens a new or existing <code>BlockStore</code> on the given sled …\nGenerate an empty block for provided Header. Transactions …\nThe <code>sled</code> tree storing the order of the blockchain’s …\nBlock ranks\nSign block header using provided secret key\nBlock producer signature\nBlock producer signature\nThe <code>sled</code> tree storing each blocks’ full database state …\nBlock target rank\nHeight cumulative targets rank\nBlock creation timestamp\nTrasaction hashes\nTransactions payload\nThe <code>ContractStore</code> is a structure representing all <code>sled</code> …\nOverlay structure over a <code>ContractStore</code> instance.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFetches the bincode for a given ContractId from the overlay…\nFetches the bincode for a given ContractId from the store…\nRetrieve all contract states from the store’s state tree …\nRetrieve all wasm bincodes from the store’s wasm tree in …\nGenerate a Monotree(SMT) containing all contracts states …\nGenerate a Monotree(SMT) containing all contracts states …\nRetrieve all records from a contract’s zkas sled tree, …\nRetrieve provided key value bytes from a contract’s zkas …\nAbstraction function for fetching a <code>ZkBinary</code> and its …\nAbstraction function for fetching a <code>ZkBinary</code> and its …\nTry to initialize a new contract state. Contracts can …\nInserts or replaces the bincode for a given ContractId …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDo a lookup of an existing contract state. In order to …\nDo a lookup of an existing contract state. In order to …\nOpens a new or existing <code>ContractStore</code> on the given sled …\nAttempt to remove an existing contract state. In order to …\nAuxiliary function to compute a blake3 checksum for …\nAuxiliary function to compute a blake3 checksum for …\nThe <code>sled</code> tree storing the pointers to contracts’ …\nCompute all updated contracts states and wasm bincodes …\nThe <code>sled</code> tree storing the wasm bincode for deployed …\nNative Darkfi PoW\nThis struct represents a tuple of the form (version, …\nThe <code>HeaderStore</code> is a structure representing all <code>sled</code> trees …\nOverlay structure over a <code>HeaderStore</code> instance.\nMonero merge mining PoW\nStruct representing the Proof of Work used in a block.\nCheck if the store’s main tree contains a given header …\nRepresents the genesis header on current timestamp.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nFetch given headerhashes from the overlay. The resulting …\nFetch given header hashes from the store’s main tree. …\nFetch n hashes after given height. In the iteration, if a …\nRetrieve all headers from the store’s main tree in the …\nRetrieve all headers from the store’s sync tree in the …\nFetch the fisrt header in the store’s sync tree, based …\nFetch the last header in the store’s sync tree, based on …\nCompute the header’s hash.\nBlock height\nInsert a slice of <code>Header</code> into the overlay. The header’s …\nInsert a slice of <code>Header</code> into the store’s main tree.\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nInsert a slice of <code>Header</code> into the store’s sync tree.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if store’s sync tree contains any records.\nRetrieve store’s sync tree records count.\nMain <code>sled</code> tree, storing all the blockchain’s blocks’ …\nGenerates a new header with default transactions and state …\nOpens a new or existing <code>HeaderStore</code> on the given sled …\nThe block’s nonce. This value changes arbitrarily with …\nBlock Proof of Work type\nPrevious block hash\nRemove all records from the store’s sync tree.\nGenerate the sled batch corresponding to a remove from the …\nRemove a slice of <code>u32</code> from the store’s sync tree.\nContracts states Monotree(SMT) root this block commits to\nThe <code>sled</code> tree storing all the node pending headers while …\nCompute the header’s template hash, which excludes its …\nBlock creation timestamp\nMerkle tree root of the transactions hashes contained in …\nBlock version\nThis struct represents all the Proof of Work information …\nAux chain Merkle proof hashes\nCoinbase Merkle proof hashes\nExtra field of the coinbase\nIncomplete hashed state of the coinbase transaction\nReturns the argument unchanged.\nMonero Header fields\nCalls <code>U::from(self)</code>.\nReturns true if the coinbase Merkle proof produces the …\nTransaction root\nRandomX VM key - length varies to a max len of 60. TODO: …\nThe number of transactions included in this Monero block. …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThe Monero Merkle proof\nReturns the Merkle proof branch as a list of Monero hashes\nCalculates the Merkle root hash from the provided Monero …\nThe coinbase must be the first transaction in the block, so\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the path bitmap of the proof\nReturns the Keccak 256 hash of the byte input\nReturns the Keccak 256 hash of 2 hashes\nCreates a Merkle proof for the given hash within the set …\nTree hash algorithm in Monero\nRound down to power of two. Should error for count &lt; 3 or …\nThe <code>TxStore</code> is a structure representing all <code>sled</code> trees …\nOverlay structure over a <code>TxStore</code> instance.\nCheck if the store’s main tree contains a given …\nCheck if the store’s pending txs tree contains a given …\nReturns the argument unchanged.\nReturns the argument unchanged.\nFetch given tx hashes from the overlay’s main tree. The …\nFetch given tx hashes from the store’s main tree. The …\nFetch n transactions after given order([order..order+n)). …\nRetrieve all transactions from the store’s main tree in …\nRetrieve all transactions locations from the store’s …\nRetrieve all transactions from the store’s pending txs …\nRetrieve all transactions from the store’s pending txs …\nFetch given tx hashes locations from the store’s …\nFetch given tx hash location from the overlay’s location …\nFetch given tx hashes from the store’s pending txs tree. …\nFetch given tx hash from the overlay’s main tree. This …\nInsert a slice of <code>Transaction</code> into the overlay’s main …\nInsert a slice of <code>Transaction</code> into the store’s main tree.\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nGenerate the sled batch corresponding to an insert to the …\nInsert a slice of <code>TransactionHash</code> into the overlay’s …\nInsert a slice of <code>TransactionHash</code> into the store’s …\nInsert a slice of <code>Transaction</code> into the store’s pending …\nInsert a slice of <code>TransactionHash</code> into the store’s …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCheck if the store’s main tree is empty.\nRetrieve records count of the store’s main tree.\nThe <code>sled</code> tree storing the location of the blockchain’s …\nMain <code>sled</code> tree, storing all the blockchain’s …\nOpens a new or existing <code>TxStore</code> on the given sled database.\nThe <code>sled</code> tree storing all the node pending transactions, …\nThe <code>sled</code> tree storing the order of all the node pending …\nGenerate the sled batch corresponding to a remove from the …\nGenerate the sled batch corresponding to a remove from the …\nRemove a slice of <code>TransactionHash</code> from the store’s …\nRemove a slice of <code>u64</code> from the store’s pending txs order …\nOur local hash table, storing DHT keys and values\nAdd a node in the correct bucket\nAdd <code>value</code> to our hash table and send <code>message</code> for a <code>key</code> to …\nLookup our own node id to bootstrap our DHT\nAre we bootstrapped?\nVec of buckets\nChannel ID -&gt; ChannelCacheItem\nDecrement the channel usage count, if it becomes 0 then …\nGet the distance between <code>key_1</code> and <code>key_2</code>\nGlobal multithreaded executor reference\nGet <code>n</code> closest known nodes to a key TODO: Can be optimized\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\n<code>key</code> -&gt; bucket index\nGet a channel (existing or create a new one) to <code>node</code> about …\nChannel ID -&gt; <code>DhtNode</code>\n<code>DhtHandler</code> that implements application-specific behaviors …\nOur local hash table, storing a part of the full DHT …\nImplements default Hash, PartialEq, and Eq for a struct …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLookup algorithm for both nodes lookup and value lookup\nFind <code>k</code> nodes closest to a key\nFind value for <code>key</code>\nNumber of buckets\nThe DHT node the channel is connected to.\nP2P network pointer\nReset the DHT state (nodes and hash table)\nDHT settings\nSort <code>nodes</code> by distance from <code>key</code>\nTopic is a hash that you set to remember what the channel …\nMove a node to the tail in its bucket, to show that it is …\nUsage count increments when you call <code>handler.get_channel()</code> …\nTrait for application-specific behaviors over a <code>Dht</code>\nAdd a value to our hash table\nThe <code>Dht</code> instance\nSend FIND NODES request to a peer to get nodes close to <code>key</code>\nSend FIND VALUE request to a peer to get a value and/or …\nDefines how keys are printed/logged\nGet our own node\nTriggered when we find a new node\nSend a DHT ping request, which is used to know the node …\nNumber of lookup requests in a burst\nMaximum number of parallel lookup requests\nNumber of DHT lookup requests in a burst\nMaximum number of parallel DHT lookup requests\nNumber of nodes in a DHT bucket\nTimeout in seconds\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nNumber of nodes in a bucket\nTimeout in seconds\nSend a DHT ping request when there is a new channel, to …\nClient module errors\nResult type used in the Client module\nContains the error value\nContains the error value\nGeneral library errors used throughout the codebase.\nContains the success value\nContains the success value\nMain result type used throughout the codebase.\nTransaction verification errors\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAuxiliary function to retrieve the vector of erroneous …\nAllowed timestamp drift in milliseconds\nAn Event Graph instance\nAtomic pointer to an <code>EventGraph</code> instance.\nGenesis event contents\nInitial genesis timestamp in millis (07 Sep 2023, 00:00:00 …\nNull event ID\nThe number of parents an event is supposed to have.\nA <code>HashSet</code> containg event IDs and their 1-level parents. …\nCurrent genesis event\nSled tree containing the DAG\nFetch an event from the DAG\nAtomically insert given events into the DAG and return the …\nAtomically prune the DAG and insert the given event as …\nBackground task periodically pruning the DAG.\nSync the DAG from connected peers\nReplay logs path.\nCurrently configured DAG rotation, in days\nDisable graph debugging\nEnable graph debugging\nEnable graph debugging\nSend a deg notification over the publisher\nThe publisher for which we can give deg info over\nSubscribe to deg events\nWe do a non-recursive DFS (…\nAn event graph event\nEvent publisher, this notifies whenever an event is …\nFetch all the events that are on a higher layers than the …\nFind the unreferenced tips in the current DAG state, …\nReturns the argument unchanged.\nGet next layer along with its N_EVENT_PARENTS from the …\nInternal function used for DAG sorting.\nCalls <code>U::from(self)</code>.\nCreate a new <code>EventGraph</code> instance, creates a new Genesis …\nPerform a topological sort of the DAG.\nPointer to the P2P network instance\nP2P protocol implementation for the Event Graph\nDAG Pruning Task\nRun in replay_mode where if set we log Sled DB instructions\nFlag signalling DAG has finished initial sync\nThe set of unreferenced DAG tips\nUtility functions\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRepresentation of an event in the Event Graph\nReturn a reference to the event’s content\nContent of the event\nFully validate an event for the correct layout against …\nReturns the argument unchanged.\nHash the <code>Event</code> to retrieve its ID\nCalls <code>U::from(self)</code>.\nDAG layer index of the event\nCreate a new event with the given data and an <code>EventGraph</code> …\nParent nodes in the event DAG\nTimestamp of the event in whole seconds\nFully validate an event for the correct layout against …\nValidate a new event for the correct layout and enforce …\nSame as <code>Event::new()</code> but allows specifying the timestamp …\nA P2P message representing publishing an event on the …\nA P2P message representing an event reply\nA P2P message representing an event request\nMalicious behaviour threshold. If the threshold is …\nP2P protocol implementation for the Event Graph.\nRolling length of the window\nRatelimit kicks in above this count\nSample point used to calculate sleep time when ratelimit …\nSleep for this amount of time when …\nA P2P message representing a reply for the peer’s DAG …\nA P2P message representing a request for a peer’s DAG …\nRolling length of the window\nGlobal limit of messages per window\n<code>MessageSubscriber</code> for <code>TipRep</code>\nWe need to rate limit message propagation so malicious …\nReceive send requests and rate-limit broadcasting them.\nTo apply the rate-limit, we don’t broadcast directly but …\nPointer to the connected peer\nClean out expired timestamps from the window.\n<code>MessageSubscriber</code> for <code>EventPut</code>\n<code>MessageSubscriber</code> for <code>EventRep</code>\n<code>MessageSubscriber</code> for <code>EventReq</code>\nPointer to the Event Graph instance\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProtocol function handling <code>EventPut</code>. This is triggered …\nProtocol function handling <code>EventReq</code>. This is triggered …\nProtocol function handling <code>TipReq</code>. This is triggered when …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nP2P jobs manager pointer\nPeer malicious message count\nAdd new timestamp\n<code>MessageSubscriber</code> for <code>TipReq</code>\nMilliSeconds in a day\nCalculate the number of days since a given midnight …\nGenerate a deterministic genesis event corresponding to …\nCalculate the midnight timestamp given a number of days. …\nCalculate the time in milliseconds until the …\nCalculate the timestamp of the next DAG rotation.\n<code>ChunkedStorage</code> is a representation of a file or directory …\nPath prefix where directory metadata is stored\nPath prefix where file metadata is stored\n<code>FileSequence</code> is an object that implements <code>AsyncRead</code>, …\nChunk-based file storage interface.\nDefined maximum size of a stored chunk (256 KiB)\nSet to <code>true</code> to automatically set the length of the file on …\nChunk a stream. Returns a hasher (containing the chunk …\nVector of chunk hashes and a bool which is <code>true</code> if the …\nCreate a ChunkedStorage from metadata. <code>hash</code> is the hash of …\nCurrently opened file\nIndex of the currently opened file in the <code>files</code> vector\nPath to the filesystem directory where directory metadata …\nList of (file path, file size). File sizes are not the …\nPath to the filesystem directory where file metadata is …\nFileSequence containing the list of file paths and file …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nPerform garbage collection over the filesystem hierarchy. …\nFetch file/directory metadata from Geode. Returns …\nFetch a single chunk from Geode. Returns a Vec containing …\nAdd chunk hashes to <code>hasher</code>.\nAdd files metadata to <code>hasher</code>. You must sort the files …\nCreate and insert file or directory metadata into Geode. …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nSet to <code>true</code> if this ChunkedStorage is the representation …\nInstantiate a new <code>Geode</code> object. <code>base_path</code> defines the root …\nRead the file at <code>file_path</code> to get its chunk with index …\nAttempt to read chunk hashes and files metadata from a …\nsmol::fs::File::read does not guarantee that the buffer …\nSorts files by their PathBuf.\nVerifies that the chunk hash matches the content.\nVerifies that the file hash matches the chunk hashes.\nWrite a single chunk given a stream. The file must be …\n<code>ChunkedStorage</code> is a representation of a file or directory …\nVector of chunk hashes and a bool which is <code>true</code> if the …\nFileSequence containing the list of file paths and file …\nReturn a mutable chunk from <code>chunks</code>.\nReturn <code>chunks</code>.\nReturn all chunks that contain parts of <code>file</code>.\nReturn the list of files from the <code>reader</code>.\nReturn <code>fileseq</code>.\nReturn a mutable <code>fileseq</code>.\nCheck whether we have all the chunks available locally.\nReturn <code>is_dir</code>.\nSet to <code>true</code> if this ChunkedStorage is the representation …\nReturn <code>true</code> if the chunked file contains no chunk.\nReturn an iterator over the chunks and their availability.\nReturn an mutable iterator over the chunks and their …\nReturn the number of chunks.\nReturn the number of chunks available locally.\n<code>FileSequence</code> is an object that implements <code>AsyncRead</code>, …\nSet to <code>true</code> to automatically set the length of the file on …\nCurrently opened file\nIndex of the currently opened file in the <code>files</code> vector\nList of (file path, file size). File sizes are not the …\nReturn <code>current_file</code>.\nCompute the starting position of the file (in bytes) by …\nReturn <code>files</code>.\nReturn <code>true</code> if the <code>FileSequence</code> contains no file.\nReturn the combined file size of all files.\nOpen the file at <code>file_index</code>.\nOpen the file at (<code>current_file_index</code> + 1). If no file is …\nUpdate a single file size.\nReturn the combined file size of all files.\nsmol::fs::File::read does not guarantee that the buffer …\nHandles the acceptance of inbound socket connections. Used …\nAsync channel that handles the sending of messages across …\nHandles the creation of outbound connections. Used to …\nOptional events based debug-notify subsystem. Off by …\nHosts are a list of network addresses used when …\nDefines how to decode generic messages as well as …\nGeneric publish/subscribe class that can dispatch any kind …\nMetering related definitions.\nP2P provides all core functionality to interact with the …\nDefines the networking protocol used at each stage in a …\nDefines the interaction between nodes during a connection.\nNetwork configuration settings. This holds the configured …\nNetwork transports, holds implementations of pluggable …\nCreate inbound socket connections\nAtomic pointer to Acceptor\nRun the accept loop in a new thread and error if a …\nReturns the argument unchanged.\nHandles network errors. Panics if errors pass silently, …\nCalls <code>U::from(self)</code>.\nCreate new Acceptor object.\nRun the accept loop.\nStart accepting inbound socket connections\nStop accepting inbound socket connections\nStart receiving network messages.\nAsync channel for communication between nodes.\nChannel debug info\nAtomic pointer to async channel\nReturns the relevant socket address for this connection. …\nBan a malicious peer and stop the channel.\nReturn the socket address without transport processing.\nReturns the address used for UI purposes like in logging …\nReturns the argument unchanged.\nReturns the argument unchanged.\nShould only be called after the version exchange has been …\nHandle network errors. Panic if error passes silently, …\nChannel debug info\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nRun the receive loop. Start receiving messages or handle …\nReturns the inner <code>MessageSubsystem</code> reference\nThe message subsystem instance for this channel\nMap holding a <code>MeteringQueue</code> for each [<code>Message</code>] to perform …\nSets up a new channel. Creates a reader and writer <code>PtStream</code>…\nReturns a decoded Message command. We start by extracting …\nThe reading half of the transport stream\nTask that is listening for the stop signal\nReturns the socket address that has undergone transport …\nSends a message across a channel. First it converts the …\nSends the encoded payload of provided <code>SerializedMessage</code> by …\nSends the encoded payload of provided <code>SerializedMessage</code> …\nWeak pointer to respective session\nSet the VersionMessage of the node this channel is …\nPerform network handshake for message subsystem …\nStarts the channel. Runs a receive loop to start receiving …\nStops the channel. Notifies all publishers that the …\nPublisher listening for stop signal for closing this …\nA boolean marking if this channel is stopped\nSubscribe to a message on the message subsystem.\nCreates a subscription to a stopped signal. If the channel …\nThe version message of the node we are connected to. Some …\nThe writing half of the transport stream\nCreate outbound socket connections\nEstablish an outbound connection\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new connector with given network settings\nWeak pointer to the session\nP2P settings\nStop signal that aborts the connector if received.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nHostile peers that can neither be connected to nor …\nHosts that are being connected to in Outbound and Manual …\nHosts that have been successfully connected to.\nPeers that do not match our accepted transports. We are …\nFree up a peer for any future operation.\nNodes to which we have already been able to establish a …\nIntermediary nodes that are periodically probed and updated\nA Container for managing Grey, White, Gold and Black …\nKeeps track of hosts and their current state. Prevents …\nHostState is a set of mutually exclusive states that can …\nMain parent class for the management and manipulation of …\nAtomic pointer to hosts object\nHosts that are currently being inserting into the hostlist.\nThe main interface for interacting with the hostlist. …\nHost that are moving between hostlists, implemented in …\nHosts that are migrating from the greylist to the …\nHosts that we have just failed to connect to. Marking a …\nWe need a convenience method from Rust’s unstable …\nRecently seen hosts. Shared with other nodes.\nUpon version exchange, the node reports our external …\nAuto self discovered addresses. Used for filtering self …\nTo block a peer trying to access by all ports, simply …\nPublisher for notifications of new channels\nReturn the list of all connected channels, including seed …\nHostlists and associated methods.\nCheck if host is in a hostlist\nPublisher listening for network disconnects\nThe external_addrs is set by the user but we need the …\nReturn all known hosts on a hostlist.\nGet up to limit peers that don’t match the given …\nGet the oldest entry from a hostlist.\nMethod to fetch the last_seen field for a give address …\nGet up to n random peers. Schemes are not taken into …\nGet up to n random peers that don’t match the given …\nGet up to n random peers that match the given transport …\nGet a random peer from a hostlist that matches the given …\nGet up to limit peers that match the given transport …\nFilter given addresses based on certain rulesets and …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGrab the channel pointer of provided channel ID, if it …\nGet the index for a given addr on a hostlist.\nGet the last_seen field for a given entry on a hostlist.\nDowngrade host to Greylist, remove from Gold or White list.\nPick the most frequent occuring reported external address …\nImport blacklisted peers specified in the config file.\nSafely insert into the HostContainer. Filters the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMarker for IPv6 availability\nCheck if a hostlist is empty.\nCheck whether a URL is IPV6\nCheck whether a URL is local host\nKeeps track of the last time a connection was made.\nLoad the hostlists from a file.\nPerforms transport mixing for an url returning a list of …\nA single function for moving hosts between hostlists. …\nCreate a new hosts list\nMake a best effort guess from the most frequently reported …\nIf the port number specified is 0, then replace it with …\nReturn the list of connected peers. Seed and refinery …\nRetrieve a random connected channel\nCheck whether a peer is available to be refined currently. …\nDelete items from a hostlist that are older than a …\nAdd a channel to the set of connected channels\nA registry that tracks hosts and their current state.\nRemove an entry from a hostlist if it exists.\nRemove the last item on a hostlist if it reaches max size.\nSave the hostlist to a file.\nPointer to configured P2P settings\nSort a hostlist by last_seen.\nAppend host to a hostlist. Called when initalizing the …\nStores an address on a hostlist or updates its last_seen …\nPublisher listening for store updates\nGet notified when a new channel has been created\nGet notified when a node has no active connections (is …\nGet notified when new hosts have been inserted into a …\nReturns the list of suspended channels.\nTry to update the registry. If the host already exists, …\nMark as host as Free which frees it up for most future …\nUpdate the last_seen field of a peer on a hostlist.\nAddrs message fields size:\nSends address information to inbound connection.\nGetAddrs message fields size:\nRequests address of outbound connection.\nMessage bytes vector length limit. Set to 0 for no limit.\nMaximum command (message name) length in bytes.\nMessage metering configuration for rate limit. Use …\nMessage metering score value. Set to 0 for no impact in …\nGeneric message template.\nPing-Pong messages fields size:\nFor each message configs a threshold was calculated by …\nOutbound keepalive message.\nInbound keepalive message.\nGeneric serialized message template.\nVerack message fields size:\nVersion message fields size:\nSends version information to inbound connection. Response …\nRequests version information of outbound connection.\nApp version\nNetwork address of the node receiving this message (before …\nExternal address of the sender node, if it exists (empty …\nList of features consisting of a tuple of (services, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMaximum number of addresses with preferred transports to …\nOnly used for debugging. Compromises privacy when set.\nNetwork address of the node receiving this message (after …\nUNIX timestamp of when the VersionMessage was created.\nPreferred addresses transports.\nIdentifies protocol version being used by the node.\nDispatcher subscriptions HashMap type.\nContains the error value\nA dispatcher that is unique to every <code>Message</code>.\nGeneric interface for the message dispatcher.\nHandles message subscriptions through a subscription ID and\n64-bit identifier for message subscription.\nGeneric publish/subscribe class that maintains a list of …\nContains the success value\nPrivate function to concurrently transmit a message to all …\nAdd a new dispatcher for specified <code>Message</code>.\nConverts to <code>Any</code> trait. Enables the dynamic modification of …\nCleans existing items from the receiver channel.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInternal function to retrieve metering queue current total …\nCreate a new message dispatcher\nCreate a new message subsystem.\nTransmits a payload to a dispatcher. Returns an error if …\nCreate a random ID.\nStart receiving messages. Sender also provides with a …\nStart receiving messages with timeout.\nSubscribe to a channel. Assigns a new ID and adds it to …\nSubscribes to a <code>Message</code>. Using the Message name, the method\nInternal function to deserialize data into a message type …\nInternal function that sends an error message to all …\nConcurrently transmits an error message across dispatchers.\nUnsubscribe from a channel. Removes the associated ID from …\nUnsubscribe from a message subscription. Must be called …\nDefault <code>MeteringConfiguration</code> as a constant, so it can be …\nStruct representing metering configuration parameters.\nStruct to keep track of some sequential metered actions …\nPrune expired metering information from the queue.\nMetering configuration of the queue.\nParameter defining the expiration of each item, for time …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nGenerate a new <code>MeteringConfiguration</code> for provided …\nGenerate a new <code>MeteringQueue</code> for provided …\nAdd new metering value to the queue, after prunning …\nRing buffer keeping track of action execution timestamp and\nSleep time for each unit over the threshold, in …\nCompute sleep time for current metered values total, based …\nDefines the threshold after which rate limit kicks in. Set …\nCompute the current metered values total.\nToplevel peer-to-peer networking interface\nAtomic pointer to the p2p interface\nBroadcasts a message concurrently across all active peers.\nAuxiliary function to broadcast a serialized message …\nBroadcast a message concurrently to all given peers.\nBroadcasts a message concurrently across active peers, …\nDisable network debugging\nEnable network debugging\nEnable network debugging\nSend a dnet notification over the publisher\nThe publisher for which we can give dnet info over\nSubscribe to dnet events\nReference the global executor\nGlobal multithreaded executor reference\nReturns the argument unchanged.\nGrab the channel pointer of provided channel ID, if it …\nReturn an atomic pointer to the list of hosts\nKnown hosts (peers)\nCalls <code>U::from(self)</code>.\nCheck whether this node has connections to any peers. This …\nInitialize a new p2p network.\nThe number of connected peers. This means channels which …\nReturn a reference to the internal protocol registry\nProtocol registry\nReseed the P2P network.\nGet pointer to inbound session\nReference to configured <code>InboundSession</code>\nGet pointer to manual session\nReference to configured <code>ManualSession</code>\nGet pointer to outbound session\nReference to configured <code>OutboundSession</code>\nGet pointer to refine session\nReference to configured <code>RefineSession</code>\nGet pointer to seedsync session\nReference to configured <code>SeedSyncSession</code>\nReturn an atomic pointer to the set network settings\nP2P network settings\nStarts inbound, outbound, and manual sessions.\nStop the running P2P subsystem\nProtocol for address and get-address messages.\nBase trait for implementing P2P protocols\nGeneric protocol to receive specified structure messages.\nManages the tasks for the network protocol.\nProtocol for ping-pong keepalive messages.\nInterface for registering arbitrary P2P protocols\nSeed server protocol. Seed server is used when connecting …\nProtocol for version information handshake between nodes …\nRegister the default network protocols for a p2p instance.\nDefines address and get-address messages.\nA vector of all currently accepted transports and valid …\nReturns the argument unchanged.\nHandles receiving the address message. Loops to …\nHandles receiving the get-address message. Continually …\nCreates a new address protocol. Makes an address, an …\nCalls <code>U::from(self)</code>.\nSend our own external addresses over a channel. Set the …\nStart the address protocol. If it’s an outbound session …\nBroadcast message to rest nodes\nDefines generic messages protocol.\nDefines generic messages protocol action signal.\nDefines a handler for generic protocol messages, consisting\nSend provided response message to the node\nSkip message broadcast\nStop the channel entirely\nThe P2P channel the protocol is serving\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRuns the message queue. We listen for the specified …\nInitialize a new generic protocol.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nPointer to the protocol job manager\nThe P2P channel message subcription\nGenerate a new ProtocolGenericHandler for the provided P2P …\nPointer to the whole P2P instance\nMessage queue receiver listening for new messages from all …\nAction signal smol channel receiver\nRegisters a new channel sender to the handler map. …\nSends provided protocol generic action to requested …\nMessage queue sender, passed to each P2P channel.\nThe generic message smol channel sender\nSenders mapped by channel ID to propagate the action …\nHandler background task to run the messages listener …\nPointer to protocol jobs manager\nCloses all open tasks. Takes all the tasks from the …\nReturns the argument unchanged.\nWaits for a stop signal, then closes all tasks. Ensures …\nCalls <code>U::from(self)</code>.\nReturns configured name\nCreate a new protocol jobs manager\nSpawns a new task and adds it to the internal queue\nRuns the task on an executor\nDefines ping and pong messages\nReturns the argument unchanged.\nCreate a new ping-pong protocol.\nCalls <code>U::from(self)</code>.\nWaits for ping, then replies with pong. Copies ping’s …\nRuns the ping-pong protocol. Creates a subscription to …\nStarts ping-pong keepalive messages exchange. Runs …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>ProtocolRegistry</code>\n<code>add_protocol()?</code>\nImplements the seed protocol\nReturns the argument unchanged.\nCreate a new seed protocol.\nCalls <code>U::from(self)</code>.\nSend our own external addresses over a channel. Set the …\nStarts the seed protocol. Creates a subscription to the …\nImplements the protocol version handshake sent out by …\nSend and receive version information\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new version protocol. Makes a version and version …\nReceive version info, check the message is okay and send …\nStart version information exchange. Start the timer. Send …\nSend version info and wait for version acknowledgement. …\nSession trait. Defines methods that are used across …\nBitwise selectors for the <code>protocol_registry</code>\nInbound connections session. Manages the creation of …\nManual connections session. Manages the creation of manual …\nOutbound connections session. Manages the creation of …\nReturns a pointer to the p2p network interface\nPerforms network handshake to initialize channel. Adds the …\n<code>RefineSession</code> manages the <code>GreylistRefinery</code>, which randomly …\nRegisters a new channel with the session. Performs a …\nRemoves channel from the list of connected channels when a …\nSeed sync session creates a connection to the seed nodes …\nReturn the session bit flag for the session type\nDefines inbound connections session\nWait for all new channels created by the acceptor and call …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCreate a new inbound session\nRegisters the channel. First performs a network handshake …\nStarts the inbound session. Begins by accepting …\nStart accepting connections for inbound session.\nStops the inbound session.\nDefines manual connections session.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new manual session.\nAttempts a connection on the associated Connector object.\nStops the manual session.\nDefines outbound connections session.\nMain PeerDiscovery process that loops through connected …\nDefines a common interface for multiple peer discovery …\nAddress selection algorithm that works as follows: up to …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new outbound session.\nWakeup peer discovery by sending a notification to …\nWeak pointer to parent p2p object\nPeer discovery task\nActivate peer discovery if not active already. For the …\nOutbound connection slots\nStart the outbound session. Runs the channel connect loop.\nStops the outbound session.\nStart making an outbound connection, using provided …\nBlocks execution until we receive a notification from …\nPeriodically probes entries in the greylist.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGlobally accessible function to perform a version exchange …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWeak pointer to parent p2p object\nTask that periodically checks entries in the greylist.\nWeak pointer to parent object\nStart the refinery and self handshake processes.\nStop the refinery and self handshake processes.\nDefines seed connections session\nReturns true if every seed attempt per slot has failed.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a new seed sync session instance\nActivate the slots so they can continue with the seedsync …\nMain seedsync connection process that is started on …\nInitialize the seedsync session. Each slot is suspended …\nStop the seedsync session.\nBan policies definitions.\nDistinguishes distinct P2P networks\nP2P network settings. The scope of this is a P2P network …\nDefines the network settings.\nWhitelisted network transports for outbound connections\nPreferred transports for outbound connections\nApplication version, used for convenient protocol matching\nDo not ban nodes that send messages without dispatchers if …\nDo not ban nodes that send messages without dispatchers if …\nNodes to avoid interacting with for the duration of the …\nNodes to avoid interacting with for the duration of the …\nExchange versions (handshake) timeout (in seconds)\nExchange versions (handshake) timeout in seconds\nPing-pong exchange execution interval (in seconds)\nPing-pong exchange execution interval in seconds\nP2P external addresses the instance advertises so other …\nP2P external addresses node advertises so other peers can …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nNumber of goldlist connections\nNumber of goldlist connections\nPause interval within greylist refinery process\nPause interval within greylist refinery process\nHostlist storage path\nHosts .tsv file to use\nI2p Socks5 proxy to connect to i2p eepsite (hidden …\nI2p Socks5 proxy to connect to i2p eepsite (hidden …\nP2P accept address node listens to for inbound connections\nP2P accept addresses the instance listens on for inbound …\nInbound connection slots number, this many active …\nInbound connection slots number\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAllow localnet hosts\nIf this is true, strictly follow the gold_connect_count and\nMagic bytes should be unique per P2P network. Avoid …\nMagic bytes used to distinguish P2P distinct networks and …\nTransports allowed to be mixed (tcp, tcp+tls, tor, tor+tls)\nTransports allowed to be mixed (tcp, tcp+tls, tor, tor+tls)\nOnly used for debugging, compromises privacy when set\nOnly used for debugging. Compromises privacy when set.\nNym socks5 proxy to connect to when socks5 or socks5+tls …\nNym socks5 proxy to connect to when socks5 or socks5+tls …\nOutbound connection timeout (in seconds)\nConnection establishment timeout in seconds\nOutbound connection slots number, this many connections …\nOutbound connection slots number\nTime between peer discovery attempts\nTime between peer discovery attempts\nCooling off time for peer discovery when unsuccessful\nCooling off time for peer discovery when unsuccessful\nP2P datastore path\nP2P datastore path\nPeer nodes to manually connect to\nPeer nodes to manually connect to\nSeed nodes to connect to for peer discovery and/or …\nSeed nodes to connect to for peers retrieval and/or …\nIf this is true, strictly follow the gold_connect_count and\nAllow localnet hosts\nNumber of seconds with no connections after which refinery …\nNumber of seconds with no connections after which refinery …\nTor socks5 proxy to connect to when socks5 or socks5+tls …\nTor socks5 proxy to connect to when socks5 or socks5+tls …\nPercent of connections to come from the whitelist\nNumber of whitelist connections\nA dialer that is able to transparently operate over …\nDialer variants\nA listener that is able to transparently listen over …\nListener variants\nNym\nNym with TLS\nWrapper trait for async listeners\nWrapper trait for async streams\nSOCKS5 proxy\nSOCKS5 proxy with TLS\nPlain TCP\nPlain TCP\nTCP with TLS\nTCP with TLS\nTor\nTor\nTor with TLS\nUnix socket\nUnix socket\nDial an instantiated <code>Dialer</code>. This creates a connection and …\nReturn a reference to the <code>Dialer</code> endpoint\nShould only be called after <code>listen()</code> in order to behave …\nThe endpoint to connect to\nThe address to open the listener on\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nListen on an instantiated <code>Listener</code>. This will open a …\nInstantiate a new <code>Dialer</code> with the given <code>Url</code> and datastore …\nInstantiate a new <code>Listener</code> with the given <code>Url</code> and …\nNym transport\nSOCKS5 proxy client\nTCP transport\nTLS upgrade mechanism\nTor transport\nUnix socket transport\nThe dialer variant (transport protocol)\nThe listener variant (transport protocol)\nUnique, randomly-generated per-connection ID that’s used …\nNym Dialer implementation\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>NymDialer</code> object\nSOCKS5 proxy client\nSOCKS5 dialer\nConnect an instantiated SOCKS5 client to the given …\nInternal dial function\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nSOCKS5 server host\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>Socks5Dialer</code> with given URI\nInstantiate a new SOCKS5 client from given host and port\nSOCKS5 server port\nTCP Dialer implementation\nTCP Listener implementation\nSize of the listen backlog for listen sockets\nInternal helper function to create a TCP socket.\nInternal helper function to create a TCP socket.\nInternal dial function\nInternal listen function\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>TcpDialer</code> with optional TTL.\nInstantiate a new <code>TcpListener</code> with given backlog size.\nWhen the user puts a port of 0, the OS will assign a …\nTTL to set for opened sockets, or <code>None</code> for default.\nTLS client configuration\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTLS server configuration\nValidate certificate DNSName.\nA static for <code>TorClient</code> reusability\nTor Dialer implementation\nTor Listener implementation\nInternal Tor Listener implementation, used with <code>PtListener</code>\nInternal dial function\nInternal listen function\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>TorDialer</code> object\nInstantiate a new <code>TorListener</code>\nUnix Dialer implementation\nUnix Listener implementation\nInternal dial function\nInternal listen function\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new <code>UnixDialer</code> object\nInstantiate a new <code>UnixListener</code> object\nClient-side JSON-RPC implementation\nClock sync utility module Clock sync module\nCommon internal functions\nVarious <code>From</code> implementations\nJSON-RPC primitives JSON-RPC 2.0 object definitions\nProvides optional <code>p2p.get_info()</code> method\nServer-side JSON-RPC implementation\nJSON-RPC settings\nJson helper methods and types\nHighly experimental JSON-RPC client implementation using …\nJSON-RPC client implementation using asynchronous channels.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstantiate a new JSON-RPC client that connects to the …\nInstantiate a new JSON-RPC client that connects to the …\nOneshot send a given JSON-RPC request over the …\nThe channel used to read the JSON-RPC response object.\nThe channel used to read the JSON-RPC response object\nThe channel used to send JSON-RPC request objects. The <code>bool</code>…\nThe channel used to send JSON-RPC request objects\nThe channel used to skip waiting for a JSON-RPC client …\nInternal function that loops on a given stream and …\nInternal function that loops on a given stream and …\nSend a given JSON-RPC request over the instantiated client …\nSend a given JSON-RPC request over the instantiated client …\nStop the JSON-RPC client. This will trigger <code>stop()</code> on the …\nStop the JSON-RPC client. This will trigger <code>stop()</code> on the …\nListen instantiated client for notifications. NOTE: …\nThe stoppable task pointer, used on <code>RpcClient::stop()</code>\nThe stoppable task pointer, used on <code>RpcChadClient::stop()</code>\nTODO: Loop through set of ntps, get their average response …\nClock sync parameters\nThis is a very simple check to verify that the system time …\nRaw NTP request execution\nInternal read function that reads from the active stream …\nInternal read function that reads from the active stream …\nInternal write function that writes a JSON-RPC object to …\nInternal read function that reads from the active stream …\nInternal write function that writes a JSON-RPC object to …\nJSON-RPC error codes. The error codes <code>[-32768, -32000]</code> are …\nID mismatch\nInternal JSON-RPC error.\nInvalid method parameter(s).\nInvalid/Unexpected reply\nThe JSON sent is not a valid Request object.\nA JSON-RPC error object\nA JSON-RPC error value (code and message)\nA JSON-RPC notification object\nA JSON-RPC request object\nA JSON-RPC response object\nWrapping enum around the available JSON-RPC object types\nA JSON-RPC subscriber for notifications\nThe method does not exist / is not available.\nInvalid JSON was received by the server. An error occurred …\nReserved for implementation-defined server-errors.\nSubscriber is a special object that yields a channel\nError code\nJSON-RPC error (code and message)\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nRequest ID\nRequest ID\nRequest ID\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nJSON-RPC version\nJSON-RPC version\nJSON-RPC version\nJSON-RPC version\nError message\nRequest method\nNotification method\nNotification method\nCreate a new <code>JsonRequest</code> object with the given method and …\nCreate a new <code>JsonNotification</code> object with the given method …\nCreate a new <code>JsonResponse</code> object with the given ID and …\nCreate a new <code>JsonError</code> object with the given error code, …\nSend a notification to the publisher with the given JSON …\nRequest parameters\nNotification parameters\nParses the element at the specified index in a …\nParses the element at the specified index in a …\nParses a <code>JsonValue</code> parameter into a <code>f64</code>. Returns the …\nAttempts to parse a <code>JsonResult</code>, converting it into a …\nParses a <code>JsonValue</code> parameter into a <code>String</code>. Returns the …\nNotification publisher\nResponse result\nConvert the object into a JSON string\nConvert the object into a JSON string\nConvert the object into a JSON string\nConvert the object into a JSON string\nConverts the provided JSON-RPC parameters into an array of …\nConverts <code>JsonResult</code> to <code>JsonResponse</code>, returning the …\nConverts <code>JsonResult</code> to <code>JsonError</code>, returning the response …\nValidates whether the provided JSON parameter is an empty …\nAsynchronous trait implementing a handler for incoming …\nAccept function that should run inside a loop for …\nAuxiliary function to handle a request in the background.\nStart a JSON-RPC server bound to the givven accept URL and …\nWrapper function around <code>accept()</code> to take the incoming …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDisabled JSON-RPC methods\nRPC server listen address\nArray type value.\nBoolean type value.\nEnum to represent one JSON value. Each variant represents …\nNull type value.\nNumber type value.\nObject type value.\nString type value.\nConvert this JSON value to <code>String</code> value with 2-spaces …\nWrite this JSON value to the given <code>io::Write</code> object as …\nReturns the argument unchanged.\nGet immutable reference to the inner value.\nGet mutable reference to the inner value.\nCalls <code>U::from(self)</code>.\nCheck if the inner value is an array.\nCheck if the inner value is a boolean.\nCheck if the inner value is null.\nCheck if the inner value is a number.\nCheck if the inner value is an object.\nCheck if the inner value is a string.\nConvert this JSON value to <code>String</code> value.\nWrite this JSON value to the given <code>io::Write</code> object as …\nImported WASM host functions\nVM memory access (read/write)\nMain WASM VM runtime implementation\nAccess control for host functions\nHost functions for interacting with db backend\nHost functions for merkle tree functions\nHost functions for sparse merkle tree functions\nHost functions for utilities\nReturn an error if the current Env section is not in the …\nInternal wasm runtime API for sled trees\nCheck if a database contains a given key.\nRemove a key from the database.\nReads a value by key from the key-value store.\nCreate a new database instance for the calling contract.\nLookup a database handle from its name. If it exists, push …\nSet a value within the transaction.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nGiven a zkas circuit, create a VerifyingKey and insert …\nAdds data to merkle tree. The tree, database connection, …\nAn SMT adapter for sled overlay storage. Compatible with …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAdds data to sparse merkle tree. The tree, database …\nHost function for logging strings.\nWill return currently configured block time target, in …\nWill return current blockchain timestamp, defined as the …\nWill return current runtime configured verifying block …\nGrabs last block from the <code>Blockchain</code> overlay and then …\nRetrieve an object from the object store specified by the …\nReturns the size (number of bytes) of an object in the …\nReads a transaction by hash from the transactions store.\nWill return current runtime configured transaction hash\nReads a transaction location by hash from the transactions …\nWill return current runtime configured verifying block …\nWrites data to the <code>contract_return_data</code> field of <code>Env</code>. The …\nSetup function of a contract\nThe WASM VM runtime environment instantiated for every …\nEntrypoint function of a contract\nGas limit for a single contract call (Single WASM instance)\nName of the wasm linear memory in our guest module\nMetadata\nPlaceholder state before any initialization\nDefine a wasm runtime.\nApply function of a contract\nThis function runs after successful execution of <code>exec</code> and …\nCurrently configured block time target, in seconds\nBlockchain overlay access\nCall a contract method defined by a <code>ContractSection</code> using …\nThe index for this call in the transaction\nThe compiled wasm bincode being executed,\nThe contract ID being executed\nState update produced by a smart contract function call\nThe contract section being executed\nCopy payload to the start of the memory\nOverlay tree handles used with <code>db_*</code>\nThis function runs when a smart contract is initially …\nThis function runs when someone wants to execute a smart …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalculate the remaining gas using wasm’s concept of …\nParent <code>Instance</code>\nA wasm instance\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nLogs produced by the contract\nGet memory, that needs to have been set fist\nDirect memory access to the VM\nProvide safe access to the memory (it must be initialized …\nThis function runs first in the entire scheme of executing …\nCreate a new wasm runtime instance that contains the given …\nObject store for transferring memory from the host to VM\nPrints the wasm contract logs.\nSerialize contract payload to the format accepted by the …\nSet the memory page size. Returns the previous memory size.\nA wasm store (global state)\nSubtract given gas cost from remaining gas in the current …\nTake Memory by value. Needed to modify the Memory object …\nThe hash for this transaction the runtime is being run …\nBlock height number runtime verifies against. For …\nCondition variable which allows a task to block until …\nSleep for any number of milliseconds.\nSimple broadcast (publish-subscribe) class\nRun a task until it has fully completed, irrespective of …\nSleep for any number of seconds.\nImplementation of async background task spawning which are …\nAsync timeout implementations\nCondition variables allow you to block a task while …\nAwaitable futures object returned by <code>condvar.wait()</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nWakeup the waiting task. Subsequent calls to this do …\nReset self ready to wait() again. The reason this is …\nReset the condition variable and wait for a notification\nSimple broadcast (publish-subscribe) class.\nSubscription to the Publisher. Created using …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConstruct a new publisher.\nPublish a message to all listening subscriptions.\nPublish a message to all listening subscriptions but …\nReceive message.\nMake sure you call this method early in your setup. That …\nMust be called manually since async Drop is not possible …\nWhen we call <code>stop()</code>, we wait until the process is …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nUsed to signal to the main running process that it should …\nStarts the task.\nStops the task. On completion, guarantees the process has …\nSends a stop signal and returns immediately. Doesn’t …\nUsed so we can keep StoppableTask in HashMap/HashSet\nAn error returned when a future times out.\nA future that times out after a duration of time.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAwaits an I/O future or times out after a duration of time.\nAwaits a future or times out after a duration of time.\nAuxiliarry structure containing all the information …\nCalls tree bounds definitions\nA Transaction contains an arbitrary number of <code>ContractCall</code> …\nAuxiliary structure to build a full <code>Transaction</code> using …\nAppend a new call tree to the forest\nBuilder builds the calls vector using the <code>DarkForest</code> and …\nCall executed\nContract calls trees forest\nCalls executed in this transaction\nCreate Schnorr signatures for the entire transaction.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGet the transaction hash\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if transaction is a PoW reward one.\nReturns true if the transaction consists of a single call …\nInitialize the builder, using provided data to generate …\nAttached ZK proofs\nAttached ZK proofs\nAttached Schnorr signatures\nVerify Schnorr signatures for the entire transaction.\nVerify ZK proofs for the entire transaction.\nCommand-line interface utilities\nVarious encoding formats\nFilesystem utilities\nReturn the most frequent element in vec or just any item.\nParsing helpers\nFilesystem path utilities\nPermuted Congruential Generator (PCG) This is an insecure …\nRing Buffer implementation\nTime utilities\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBase32 encoding and decoding Base32 encoding as specified …\nBase64 encoding and decoding\nStandard Base32 alphabet.\nTries to decode a base32 string into a byte vector. …\nEncode a byte slice with the given base32 alphabet into a …\nTries to decode a base64 string into a byte vector. …\nEncode a byte slice into a base64 string\nReturns <code>$XDG_CONFIG_HOME</code>, <code>$HOME/.config</code>, or <code>None</code>.\nReturns the path to the user’s home directory. Use <code>$HOME</code>…\nJoin a path with <code>config_dir()/darkfi</code>.\nReturns the path to the user’s home directory. Use <code>$HOME</code>…\nGet the home directory from the passwd entry of the …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nA ring buffer of fixed capacity\nProvides a reference to the back element, or <code>None</code> if empty.\nReturns true if the buffer contains an element equal to …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns true if buffer is empty, false otherwise\nReturns a front-to-back iterator\nReturns the current number of items in the buffer\nRearranges the internal storage of this deque so it is one …\nCreate a new <code>RingBuffer</code> with given fixed capacity\nRemoves and returns the oldest item in the buffer\nPush an element to the back of the <code>RingBuffer</code>, removing …\nCast the ringbuffer into a vec\nRepresents the number of days in each month for both leap …\nRepresents a UTC <code>DateTime</code> with individual fields for date …\nWrapper struct to represent system timestamps.\nAdd <code>self</code> to a given timestamp Errors on integer overflow.\nSubtract <code>self</code> with a given timestamp Errors on integer …\nGenerate a <code>Timestamp</code> of the current time.\nCalculates the elapsed time of a <code>Timestamp</code> up to the time …\nFormats a <code>Duration</code> into a user-friendly format using days, …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nProvides a <code>DateTime</code> instance from a string in “…\nReturns the inner <code>u64</code> of <code>Timestamp</code>\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAuxiliary function that determines whether the specified …\nThis struct represents a DarkFi validator node.\nConfiguration for initializing <code>Validator</code>\nAtomic pointer to validator.\nApply provided set of <code>BlockInfo</code> without doing formal …\nValidate a set of <code>BlockInfo</code> in sequence and apply them if …\nValidate a producer <code>Transaction</code> and apply it if valid. In …\nValidate a set of <code>Transaction</code> in sequence and apply them …\nThe node locks its consensus state and tries to append …\nThe node retrieves a transaction, validates its state …\nAuxiliary function to retrieve current best fork next …\nCanonical (confirmed) blockchain\nAuxiliary function to compute provided transaction’s …\nThe node checks if best fork can be confirmed. If …\nCurrently configured confirmation security threshold\nDarkFi consensus module\nHot/Live data used by the consensus algorithm\nFee calculation helpers\nReturns the argument unchanged.\nReturns the argument unchanged.\nGenesis block\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nDarkFi PoW module\nOptional fixed difficulty, for testing purposes\nCurrently configured PoW target\nThe node removes invalid transactions from the pending txs …\nAuxiliary function to rebuild the block difficulties …\nAuxiliary function to reset the validator blockchain and …\nFlag signalling node has finished initial sync\nHelper utilities\nRetrieve all existing blocks and try to apply them to an …\nVerification functions\nFlag to enable tx fee verification\nFlag to enable tx fee verification\nGas limit for total block transactions(50 full …\nThis struct represents the information required by the …\nStruct representing a forked blockchain state.\nThis struct represents a block proposal, used for …\nLock to restrict when proposals appends can happen\nGiven a proposal, the node verifys it and finds which fork …\nAuxiliary function to append a proposal and update current …\nAuxiliary function to retrieve current best fork last …\nBlock data\nCanonical (confirmed) blockchain\nCanonical (confirmed) blockchain\nBuild current contract states checksums monotree.\nCheck if best fork proposals can be confirmed. Consensus …\nFork size(length) after which it can be confirmed\nFork proposal overlay diffs sequence\nGiven a proposal, find the fork chain it extends, and …\nFork chains containing block proposals\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nAuxiliary function to create a full clone using …\nGenerate a new empty fork.\nAuxiliary function to retrieve the fork header hash of …\nAuxiliary function to retrieve the fork headers of …\nAuxiliary function to retrieve the fork proposals of …\nAuxiliary function to retrieve a fork proposals, starting …\nAuxiliary function to compute forks’ next block height.\nBlock hash\nCurrent fork hashes rank, cached for better performance\nAuxiliary function to check current contracts states …\nAuxiliary function to check current contracts states …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAuxiliary function to retrieve last proposal.\nValid pending transaction hashes\nCanonical blockchain PoW module state\nCurrent PoW module state\nGenerate a new Consensus state.\nOverlay cache over canonical Blockchain\nFork proposal hashes sequence\nAuxiliary function to fully purge current forks and leave …\nAuxiliary function to purge current forks and reset the …\nAuxiliary function to reset PoW module.\nCurrent contracts states checksums Monotree(SMT)\nCurrent fork mining targets rank, cached for better …\nAuxiliary function to retrieve unproposed valid …\nAuxiliary struct representing the full gas usage breakdown …\nFixed fee for verifying Schnorr signatures using the …\nCalculate the gas use for verifying a given zkas circuit. …\nAuxiliary function to compute the corresponding fee value …\nContract deployment gas\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nTransaction paid fee\nSignature fee\nCalculates the total gas used by summing all individual …\nWasm calls gas consumption\nZK circuits gas consumption\nHow many most recent blocks to use to verify new blocks’ …\nTime limit in the future of what blocks can be\nRing buffer length. Must be == DIFFICULTY_WINDOW + …\nAlready known cutoff start index for this config\nAlready known cutoff end index for this config\nAmount of max items(blocks) to use for next difficulty …\nThis struct represents the information required by the PoW …\nMax items to use for next difficulty calculation. Must be …\nUsed to calculate how many items to retain for next …\nAmount of latest blocks to exlude from the calculation. …\nAppend provided timestamp and difficulty to the ring …\nAppend provided block difficulty to the ring buffers and …\nTotal blocks cumulative difficulty Note: we keep this as a …\nCalculate cutoff indexes. If buffers have been filled, we …\nLatest block cumulative difficulties ringbuffer\nOptional fixed difficulty\nReturns the argument unchanged.\nGenesis block timestamp\nCalls <code>U::from(self)</code>.\nMine provided block, based on provided PoW module next …\nMine provided block, based on next mine target.\nCompute the next mining difficulty, based on current ring …\nCompute the next mine target.\nCompute the next mine target and difficulty.\nTarget block time, in seconds\nLatest block timestamps ringbuffer\nVerify provided block corresponds to next mine target.\nVerify provided block timestamp and hash.\nVerify provided block timestamp is not far in the future …\nVerify provided difficulty corresponds to the next one.\nVerify provided block timestamp is valid and matches …\nAuxiliary function to find best ranked fork.\nCompute a block’s rank, assuming that its valid, based …\nDeploy DarkFi native wasm contracts to provided blockchain …\nGiven a proposal, find the index of a fork chain it …\nAuxiliary function to calculate the middle value between …\nVerify provided header is valid for provided mining target …\nAuxiliary function to calculate the median of a given …\nApply given producer <code>Transaction</code> to the provided overlay, …\nApply given <code>Transaction</code> to the provided overlay. …\nApply given set of <code>Transaction</code> in sequence, without formal …\nValidate provided block according to set rules.\nA blockchain is considered valid, when every block is …\nVerify given <code>BlockInfo</code>, and apply it to the provided …\nVerify given checkpoint <code>BlockInfo</code>, and apply it to the …\nVerify given <code>Proposal</code> against provided fork state.\nVerify given genesis <code>BlockInfo</code>, and apply it to the …\nVerify block proposer signature, using the producer …\nVerify provided producer <code>Transaction</code>.\nVerify given <code>Proposal</code> against provided consensus state.\nVerify WASM execution, signatures, and ZK proofs for a …\nVerify a set of <code>Transaction</code> in sequence and apply them if …\nExport witness.json which can be used by zkrunner for …\nReturns the argument unchanged.\nZK gadget implementations\nImport witness.json which can be used to debug or …\nCalls <code>U::from(self)</code>.\nProof creation API\nTrace computation of intermediate values in circuit\nHalo2 zkas virtual machine\nVM heap variable definitions and utility functions VM heap …\nCall this before <code>Proof::create()</code> to perform type checks on …\nExport witness.json which can be used by zkrunner for …\nImport witness.json which can be used to debug or …\nCall this before <code>Proof::create()</code> to perform type checks on …\nBase field arithmetic gadget\nConditional selection\nis_equal comparison gadget\nis_zero comparison gadget\nField-native less than comparison gadget with a lookup …\nField-native range check gadget with a lookup table\nSmall range check, 0..8 bits\nPoseidon-based sparse Merkle tree chip\nConditional selection based on lhs (will output lhs if …\nArithmetic Chip\nConfiguration for the Arithmetic Chip\nArithmetic instructions implemented in the chip\nlhs\nAdd two field elements and return their sum\nrhs\nout\nConfigure the Arithmetic chip with the given columns\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMultiply two field elements and return their product\nSelector for the <code>add</code> operation\nSelector for the <code>mul</code> operation\nSelector for the <code>sub</code> operation\nSubtract two field elements and return their difference\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nThis is the main chip function. Attempts to witness the …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\n<code>k_values_table</code> should be reused across different chips …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nChecks that an expression is in the small range [0..range),\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConfigure the chip.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn advice column\nA value assigned to a cell within a circuit.\nAn assigned cell.\nA column with an index and type\nThis trait represents an element of a field.\nA layout strategy within a circuit. The layouter is …\nThe one element of the field, the multiplicative identity.\nA value stored as a fraction to enable batch inversion.\nRepresents the type of the “root” of this layouter, so …\nA value that does not require inversion to evaluate.\nA value that might exist within a circuit.\nThe zero element of the field, the additive identity.\nThe field element zero.\nReturns <code>Value::unknown()</code> if the value is <code>Value::unknown()</code>, …\nConverts from <code>&amp;mut Value&lt;V&gt;</code> to <code>Value&lt;&amp;mut V&gt;</code>.\nConverts from <code>&amp;Value&lt;V&gt;</code> to <code>Value&lt;&amp;V&gt;</code>.\nEnforces an assertion on the contained value, if known.\nAssign a region of gates to an absolute row number.\nAssign a table region to an absolute row number.\nReturns the cell.\nMaps a <code>Value&lt;&amp;V&gt;</code> to a <code>Value&lt;V&gt;</code> by cloning the contents of …\nMaps a <code>Value&lt;&amp;mut V&gt;</code> to a <code>Value&lt;V&gt;</code> by cloning the contents …\nType of this column.\nConstrains a <code>Cell</code> to equal an instance column’s row …\nMaps a <code>Value&lt;&amp;mut V&gt;</code> to a <code>Value&lt;V&gt;</code> by copying the contents …\nMaps a <code>Value&lt;&amp;V&gt;</code> to a <code>Value&lt;V&gt;</code> by copying the contents of …\nCopies the value to a given advice cell and constrains …\nCubes this element.\nCubes this field element.\nCubes this element.\nReturns the denominator, if non-trivial.\nTools for developing circuits.\nDoubles this element.\nDoubles this field element.\nDoubles this element.\nChecks the contained value for an error condition, if …\nEvaluates this value directly, performing an unbatched …\nEvaluates this assigned cell’s value directly, …\nEvaluates this assigned value directly, performing an …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nTakes each element in the <code>Iterator</code>: if it is …\nGets the “root” of this assignment, bypassing the …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the field element corresponding to this value.\nComputes the multiplicative inverse of this element, …\nInverts this assigned value (taking the inverse of zero to …\nInverts this assigned value (taking the inverse of zero to …\nReturns true iff this element is zero.\nReturns true iff this element is zero.\nReturns true iff this element is zero.\nConstructs a known value.\nMaps a <code>Value&lt;V&gt;</code> to <code>Value&lt;W&gt;</code> by applying a function to the …\nEnters into a namespace.\nReturns the numerator.\nThis module provides an implementation of a variant of …\nExits out of the existing namespace.\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nExponentiates <code>self</code> by <code>exp</code>, where <code>exp</code> is a little-endian …\nCreates a new (sub)namespace and enters into it.\nReturns an element chosen uniformly at random using a …\nReturns the square root of the field element, if it is …\nEquivalent to <code>Self::sqrt_ratio(self, one())</code>.\nComputes:\nSquares this element.\nSquares this field element.\nSquares this element.\nReturns the field element corresponding to this value.\nTransposes a <code>Value&lt;[V; LEN]&gt;</code> into a <code>[Value&lt;V&gt;; LEN]</code>.\nTransposes a <code>Value&lt;impl IntoIterator&lt;Item = V&gt;&gt;</code> into a …\nConstructs an unwitnessed value.\nUnzips a value containing a tuple of two values.\nReturns the value of the <code>AssignedCell</code>.\nReturns the field element value of the <code>AssignedCell</code>.\nZips <code>self</code> with another <code>Value</code>.\nA cell used in an active gate was not assigned to.\nMeasures a circuit to determine its costs, and explain …\nA struct for collecting and displaying the gates within a …\nGraphical renderer for circuit layouts.\nA constraint was not satisfied for a particular row.\nA constraint was active on an unusable row, and is likely …\nThe location within the circuit at which a particular …\nA location inside a region.\nAn instance cell used in an active gate was not assigned …\nA lookup input did not exist in its corresponding table.\nA test prover for debugging circuits.\nA location outside of a region.\nA permutation did not preserve the original value of a …\nA helper type that augments a <code>FloorPlanner</code> with <code>tracing</code> …\nThe reasons why a particular circuit is not satisfied.\nPanics if the circuit being checked by this <code>MockProver</code> is …\nBuilds a dot graph string representing the given circuit.\nCollects the gates from within the circuit.\nDeveloper tools for investigating the cost of a circuit.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the marginal proof size per instance of this …\nMarks cells involved in equality constraints, in red.\nMeasures a circuit with parameter constant <code>k</code>.\nMetadata about circuits.\nReturns the proof size for the given number of instances …\nPrints the queries in this circuit to a CSV grid.\nRenders the given circuit on the given drawing area.\nRuns a synthetic keygen-and-prove operation on the given …\nDraws red lines between equality-constrained cells.\nSets the visibility of region labels.\nReturns <code>Ok(())</code> if this <code>MockProver</code> is satisfied, or a list …\nSets the view height for this layout, as a number of rows.\nSets the view width for this layout, as a number of …\nThe offset (relative to the start of the region) at which …\nThe region in which the failure occurred.\nThe circuit row on which the failure occurred.\nThe values of the virtual cells used by this constraint.\nThe column in which this cell should be assigned.\nThe column in which this cell should be assigned.\nThe column in which this permutation is not satisfied.\nThe polynomial constraint that is not satisfied.\nThe polynomial constraint that is not satisfied.\nThe index of the active gate.\nThe index of the active gate.\nThe offset (relative to the start of the region) at which …\nThe offset (relative to the start of the region) at which …\nThe location at which this constraint is not satisfied.\nThe location at which the lookup is not satisfied.\nThe location at which the permutation is not satisfied.\nThe index of the lookup that is not satisfied. These …\nThe offset (relative to the start of the region) at which …\nThe region in which this cell should be assigned.\nThe region in which this gate was activated.\nThe absolute row at which this cell should be assigned.\nMeasures a circuit to determine its costs, and explain …\nThe marginal size of a Halo 2 proof, broken down into its …\nThe size of a Halo 2 proof, broken down into its …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nMetadata about a column within a circuit.\nMetadata about a configured constraint within a circuit.\nMetadata about a configured gate within a circuit.\nMetadata about an assigned region within a circuit.\nA “virtual cell” is a PLONK cell that has been queried …\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAn advice column\nAn Advice variant\nThis is an advice (witness) column queried at a certain …\nQuery of advice column at a certain relative location\nAn enum over the Advice, Fixed, Instance structs\nA value assigned to a cell within a circuit.\nThis trait allows a <code>Circuit</code> to direct some backend to …\nA verifier that checks multiple proofs in a batch. <strong>This </strong>…\nOut of bounds index passed to a backend\nThis is a trait that circuits provide implementations for …\nA column with an index and type\nA <code>TableColumn</code> has not been assigned.\nThe instance sets up a copy constraint involving a column …\nA column type\nThis is a configuration object that stores things like …\nThis is a constant polynomial\nAn individual polynomial constraint.\nThis is a description of the circuit environment, such as …\nThe constraint system is not satisfied.\nA set of polynomial constraints with a common selector.\nThis is an error that could occur during proving or …\nLow-degree expression representing an identity that must …\nA fixed column\nA Fixed variant\nThis is a fixed column queried at a certain relative …\nQuery of fixed column at a certain relative location\nA floor planning strategy for a circuit.\nThe floor planner used for this circuit. This is an …\nGate\nAn instance column\nAn Instance variant\nThis is an instance (external) column queried at a certain …\nQuery of instance column at a certain relative location\nInstance provided exceeds number of available rows\nThe provided instances do not match the circuit parameters.\nThis is a negated polynomial\nCircuit synthesis requires global constants, but circuit …\n<code>k</code> is too small for the given circuit.\nOpening error\nThe output type of this verification strategy after …\nAttempt to overwrite a default value\nOptional circuit configuration parameters. Requires the …\nRepresents the minimal parameters that determine a …\nMinimal representation of a verification key that can be …\nThis is the product of two polynomials\nThis is a proving key which allows for the creation of …\nA value stored as a fraction to enable batch inversion.\nThis is a scaled polynomial\nA selector, representing a fixed boolean value per row of …\nThis is a virtual selector\nA verifier that checks a single proof at a time.\nThis is the sum of two polynomials\nThis is an error that can occur during synthesis of the …\nA fixed column of a lookup table.\nThis is an error that could occur during table synthesis.\nAn error relating to a lookup table.\nTranscript error\nA value that does not require inversion to evaluate.\nA Table has columns of uneven lengths.\nAttempt to assign a used <code>TableColumn</code>\nTrait representing a strategy for verifying Halo 2 proofs.\nThis is a verifying key which allows for the verification …\nExposes the “virtual cells” that can be queried while …\nThe field element zero.\nAdds a proof to the batch.\nAllocate a new advice column\nAssign an advice column value (witness)\nAssign a fixed value\nCompute the number of blinding factors necessary to …\nAllocate a new complex selector that can appear anywhere …\nThe circuit is given an opportunity to describe the exact …\nThe circuit is given an opportunity to describe the exact …\nReturn the constraint name\nAssign two cells to have the same value\nCreates a new gate.\nThis creates a proof for the provided <code>circuit</code> when given …\nCompute the degree of this polynomial\nCompute the degree of the constraint system (the maximum …\nEnable this selector at the given offset within the given …\nEnables this fixed column to be used for global constant …\nEnable equality on this TableColumn.\nEnable the ability to enforce equality over cells in this …\nEnables a selector at the given row.\nCreates a new region and enters into it.\nEvaluate the polynomial using the provided closures to …\nExits the current region.\nFills a fixed <code>column</code> starting from the given <code>row</code> with …\nFinalizes the batch and checks its validity.\nAllocate a new fixed column\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReads a verification key from a slice of bytes using …\nReads a proving key from a slice of bytes using <code>Self::read</code>.\nReturn <code>self.advice_queries</code>\nReturn <code>self.constants</code>\nGet the underlying <code>EvaluationDomain</code>.\nReturn <code>self.fixed_queries</code>\nReturn <code>self.gates</code>\nReturn <code>self.instance_queries</code>\nReturn <code>self.lookups</code>\nReturn <code>self.minimum_degree</code>\nReturn <code>self.num_advice_columns</code>\nReturn <code>self.num_advice_queries</code>\nReturn <code>self.num_fixed_columns</code>\nReturn <code>self.num_instance_columns</code>\nReturn <code>self.num_selectors</code>\nReturn <code>self.permutation</code>\nReturn <code>self.selector_map</code>\nGet the underlying <code>VerifyingKey</code>.\nHashes a verification key into a transcript.\nAllocate a new instance column\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nIs this selector “simple”? Simple selectors can only …\nGenerate a <code>ProvingKey</code> from a <code>VerifyingKey</code> and an instance …\nGenerate a <code>VerifyingKey</code> from an instance of <code>Circuit</code>.\nAdd a lookup argument for some input expressions and table …\nAllocates a new fixed column that can be used in a lookup …\nReturns the minimum necessary rows that need to exist in …\nReturn the gate name\nConstructs a new batch verifier.\nConstructs a new single proof verifier.\nReturns a reference to the parameters that should be used …\nObtain a pinned version of this constraint system; a …\nObtains a pinned representation of this verification key …\nReturn the gate polynomials\nExits out of the existing namespace.\nObtains an MSM from the verifier strategy and yields back …\nCreates a new (sub)namespace and enters into it.\nReturn the queried selectors in the gate\nQuery an advice column at a relative position\nQuery an Any column at a relative position\nQuery a fixed column at a relative position\nQueries the cell of an instance column at a particular …\nQuery an instance column at a relative position\nQuery a selector at the current position.\nReads a verification key from a buffer.\nReads a proving key from a buffer. Does so by reading …\nAllocate a new (simple) selector. Simple selectors cannot …\nSets the minimum degree required by the circuit, which can …\nSquare this expression.\nGiven the provided <code>cs</code>, synthesize the given circuit.\nGiven the provided <code>cs</code>, synthesize the circuit. The …\nWrites a verifying key to a vector of bytes using …\nWrites a proving key to a vector of bytes using <code>Self::write</code>…\nReturns a boolean indicating whether or not the proof is …\nConstructs a set of constraints that are controlled by the …\nReturns a copy of this circuit with no witness values …\nWrites a verifying key to a buffer.\nWrites a proving key to a buffer.\nThe current value of <code>k</code> being used.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreates a hex formatted string of the data (big endian)\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nBase field arithmetic chip\nBoolean check\nConditional selection\nECC Chip\n253 bit <code>a &lt; b</code> check\nMerkle tree chip (using Sinsemilla)\n253 bit native range check\n64 bit native range check\nPoseidon hash chip\nSinsemilla chip\nSparse merkle tree (using Poseidon)\nAvailable chips/gadgets in the zkvm\nzkvm configuration\nZero-Cond selection\nConfiguration parameters for the circuit. Defines which …\nChips used in the circuit\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nInstance column used for public inputs\nAdvice column used to witness values\nThese represent the witness types inside the circuit\nThese represent the witness types outside of the circuit\nHelper function for verifiers to generate empty witnesses …\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nAnalyzer module\nLanguage AST\nCompiler module\nConstants\nDecoder module\nError emitter\nLexer module\nLanguage opcodes\nParser module\nLanguage types\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nVersion of the binary\nMagic bytes prepended to the binary\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nAllowed fields for proofs\nMaximum allowed k param (circuit rows = 2^k)\nMaximum allowed namespace length in bytes\nMinimum size allowed for a syntactically valid ZkBinary …\nA ZkBinary decoded from compiled zkas code. This is used …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nBase field element addition\nBase field element multiplication\nBase field element subtraction\nCheck if a field element fits in a boolean (Either 0 or 1)\nConditionally select between two base field elements given …\nConstrain equality of two Base field elements inside the …\nConstrain equality of two EcPoint elements inside the …\nConstrain a Base field element to a circuit’s public …\nDebug a variable’s value in the ZK circuit table.\nElliptic curve addition\nGet the x coordinate of an elliptic curve point\nGet the y coordinate of an elliptic curve point\nElliptic curve multiplication\nElliptic curve multiplication with a Base field element\nElliptic curve multiplication with a Base field element of …\nVariable Elliptic curve multiplication with a Base field …\nLoosely two Base field elements and see if a is less than b\nStrictly compare two Base field elements and see if a is …\nCalculate Merkle root, given a position, Merkle path, and …\nIntermediate opcode for the compiler, should never appear …\nOpcodes supported by the zkas VM\nPoseidon hash of N Base field elements\nRange check a Base field element, given bit-width (up to …\nCalculate sparse Merkle root, given the position, path and …\nWitness an unsigned integer into a Base field element\nConditionally select between a and b (return a if a is …\nReturn a tuple of vectors of types that are accepted by a …\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nzkas language builtin keywords. These can not be used …\nForbidden namespaces\nValid EcFixedPoint constant names supported by the VM.\nValid EcFixedPointBase constant names supported by the VM.\nValid EcFixedPointShort constant names supported by the VM.\nRoutine checks on section structure\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCatch-all for any type\nBase field element\nBase field element array\nDummy intermediate type\nDummy intermediate type\nElliptic curve fixed point (a constant)\nElliptic curve fixed point in base field\nElliptic curve fixed point short\nElliptic curve nonidentity point\nElliptic curve point\nHeap types in bincode &amp; vm\nLiteral types supported by the zkas VM\nMerkle tree path\nScalar field element\nScalar field element array\nSparse merkle tree path\nUnsigned 32-bit integer\nUnsigned 64-bit integer\nUnsigned 64-bit integer\nVarable types supported by the zkas VM\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.")